---
# Manual software installations
# For software not available in standard package managers

###############################################################################
# Load tool definitions
###############################################################################

- name: Include manual tools variables
  include_vars: manual_tools.yml
  tags: ['manual']

- name: Set extended PATH for tool checks
  set_fact:
    extended_path: "{{ ansible_env.HOME }}/.local/bin:{{ ansible_env.HOME }}/.cargo/bin:{{ ansible_env.HOME }}/.bun/bin:{{ ansible_env.HOME }}/google-cloud-sdk/bin:/home/linuxbrew/.linuxbrew/bin:/opt/nvim-linux-x86_64/bin:/usr/local/bin:{{ ansible_env.PATH }}"
  tags: ['manual']

###############################################################################
# Curl/Shell Script Installers (data-driven)
###############################################################################

- name: "Check if {{ item.name }} is installed (stat)"
  stat:
    path: "{{ item.check_path }}"
  register: curl_tool_stat
  when: item.check_type | default('command') == 'stat'
  loop: "{{ curl_install_tools }}"
  loop_control:
    label: "{{ item.name }}"
  tags: ['manual']

- name: "Check if {{ item.name }} is installed (command)"
  command: "which {{ item.check_command }}"
  environment:
    PATH: "{{ extended_path }}"
  register: curl_tool_cmd
  ignore_errors: yes
  changed_when: false
  when: item.check_type | default('command') == 'command'
  loop: "{{ curl_install_tools }}"
  loop_control:
    label: "{{ item.name }}"
  tags: ['manual']

- name: Build curl tools installation status
  set_fact:
    curl_tools_status: "{{ curl_tools_status | default({}) | combine({item.item.name: (item.stat.exists if item.stat is defined else item.rc == 0)}) }}"
  loop: "{{ curl_tool_stat.results + curl_tool_cmd.results }}"
  loop_control:
    label: "{{ item.item.name if item.item is defined else 'skip' }}"
  when:
    - item.item is defined
    - not (item.skipped | default(false))
  tags: ['manual']

- name: "Install {{ item.name }}"
  shell: "{{ item.script }}"
  become: "{{ item.become | default(false) }}"
  when: not (curl_tools_status[item.name] | default(false))
  loop: "{{ curl_install_tools }}"
  loop_control:
    label: "{{ item.name }}"
  tags: ['manual']

- name: "Run post-install for {{ item.name }}"
  shell: "{{ item.post_install }}"
  args:
    executable: /bin/bash
  when:
    - item.post_install is defined
    - not (curl_tools_status[item.name] | default(false))
  loop: "{{ curl_install_tools }}"
  loop_control:
    label: "{{ item.name }}"
  tags: ['manual']

###############################################################################
# Git Clone Tools (data-driven)
###############################################################################

- name: Ensure parent directories exist for git tools
  file:
    path: "{{ item.dest | dirname }}"
    state: directory
    mode: '0755'
  loop: "{{ git_clone_tools }}"
  loop_control:
    label: "{{ item.name }}"
  tags: ['manual']

- name: "Check if {{ item.name }} is installed"
  stat:
    path: "{{ item.check_path }}"
  register: git_tool_check
  loop: "{{ git_clone_tools }}"
  loop_control:
    label: "{{ item.name }}"
  tags: ['manual']

- name: "Install {{ item.0.name }}"
  git:
    repo: "{{ item.0.repo }}"
    dest: "{{ item.0.dest }}"
    version: "{{ item.0.version }}"
  when: not item.1.stat.exists
  loop: "{{ git_clone_tools | zip(git_tool_check.results) | list }}"
  loop_control:
    label: "{{ item.0.name }}"
  tags: ['manual']

###############################################################################
# Bitwarden CLI (special: zip extraction)
###############################################################################

- name: Check if Bitwarden CLI is installed
  command: which bw
  environment:
    PATH: "{{ extended_path }}"
  register: bw_check
  ignore_errors: yes
  changed_when: false
  tags: ['manual', 'bitwarden']

- name: Install Bitwarden CLI
  block:
    - name: Create temporary directory for Bitwarden CLI
      tempfile:
        state: directory
      register: bw_temp_dir

    - name: Download Bitwarden CLI
      get_url:
        url: https://vault.bitwarden.com/download/?app=cli&platform=linux
        dest: "{{ bw_temp_dir.path }}/bw.zip"

    - name: Unzip Bitwarden CLI
      unarchive:
        src: "{{ bw_temp_dir.path }}/bw.zip"
        dest: "{{ bw_temp_dir.path }}"
        remote_src: yes

    - name: Install Bitwarden CLI to /usr/local/bin
      copy:
        src: "{{ bw_temp_dir.path }}/bw"
        dest: /usr/local/bin/bw
        mode: '0755'
        remote_src: yes
      become: yes

    - name: Clean up Bitwarden CLI temp directory
      file:
        path: "{{ bw_temp_dir.path }}"
        state: absent
  when: bw_check.rc != 0
  tags: ['manual', 'bitwarden']

###############################################################################
# Kitty Terminal (special: custom installer with symlinks)
###############################################################################

- name: Check if Kitty is installed
  command: which kitty
  environment:
    PATH: "{{ extended_path }}"
  register: kitty_check
  ignore_errors: yes
  changed_when: false
  tags: ['manual', 'kitty']

- name: Install Kitty Terminal
  shell: |
    curl -L https://sw.kovidgoyal.net/kitty/installer.sh | sh /dev/stdin
    ln -sf ~/.local/kitty.app/bin/kitty ~/.local/kitty.app/bin/kitten ~/.local/bin/
    mkdir -p ~/.local/share/applications
    cp ~/.local/kitty.app/share/applications/kitty.desktop ~/.local/share/applications/
    cp ~/.local/kitty.app/share/applications/kitty-open.desktop ~/.local/share/applications/
    sed -i "s|Icon=kitty|Icon=$(readlink -f ~)/.local/kitty.app/share/icons/hicolor/256x256/apps/kitty.png|g" ~/.local/share/applications/kitty*.desktop
    sed -i "s|Exec=kitty|Exec=$(readlink -f ~)/.local/kitty.app/bin/kitty|g" ~/.local/share/applications/kitty*.desktop
    echo 'kitty.desktop' > ~/.config/xdg-terminals.list
  when: kitty_check.rc != 0
  tags: ['manual', 'kitty']

###############################################################################
# Lazygit (special: GitHub release with version detection)
###############################################################################

- name: Check if Lazygit is installed
  command: which lazygit
  environment:
    PATH: "{{ extended_path }}"
  register: lazygit_check
  ignore_errors: yes
  changed_when: false
  tags: ['manual', 'lazygit']

- name: Install Lazygit
  block:
    - name: Get latest Lazygit version
      uri:
        url: https://api.github.com/repos/jesseduffield/lazygit/releases/latest
        return_content: yes
      register: lazygit_release

    - name: Download and install Lazygit
      shell: |
        LAZYGIT_VERSION="{{ lazygit_release.json.tag_name | regex_replace('^v', '') }}"
        TEMP_DIR=$(mktemp -d)
        curl -Lo "$TEMP_DIR/lazygit.tar.gz" "https://github.com/jesseduffield/lazygit/releases/download/v${LAZYGIT_VERSION}/lazygit_${LAZYGIT_VERSION}_Linux_x86_64.tar.gz"
        tar xf "$TEMP_DIR/lazygit.tar.gz" -C "$TEMP_DIR" lazygit
        install "$TEMP_DIR/lazygit" -D -t /usr/local/bin/
        rm -rf "$TEMP_DIR"
      become: yes
  when: lazygit_check.rc != 0
  tags: ['manual', 'lazygit']

###############################################################################
# Neovim (special: tarball to /opt)
###############################################################################

- name: Check if Neovim is installed
  command: which nvim
  environment:
    PATH: "{{ extended_path }}"
  register: nvim_check
  ignore_errors: yes
  changed_when: false
  tags: ['manual', 'neovim']

- name: Install Neovim
  shell: |
    TEMP_DIR=$(mktemp -d)
    curl -Lo "$TEMP_DIR/nvim.tar.gz" https://github.com/neovim/neovim/releases/latest/download/nvim-linux-x86_64.tar.gz
    rm -rf /opt/nvim-linux-x86_64
    tar -C /opt -xzf "$TEMP_DIR/nvim.tar.gz"
    rm -rf "$TEMP_DIR"
  become: yes
  when: nvim_check.rc != 0
  tags: ['manual', 'neovim']

###############################################################################
# Yazi File Manager (special: GitHub release)
###############################################################################

- name: Check if Yazi is installed
  command: which yazi
  environment:
    PATH: "{{ extended_path }}"
  register: yazi_check
  ignore_errors: yes
  changed_when: false
  tags: ['manual', 'yazi']

- name: Install Yazi
  block:
    - name: Get latest Yazi release URL
      shell: |
        curl -s https://api.github.com/repos/sxyazi/yazi/releases/latest \
          | grep "browser_download_url" \
          | grep "x86_64-unknown-linux-gnu.tar.gz" \
          | cut -d '"' -f 4
      register: yazi_url
      changed_when: false

    - name: Download and install Yazi
      shell: |
        TEMP_DIR=$(mktemp -d)
        curl -L "{{ yazi_url.stdout }}" -o "$TEMP_DIR/yazi.tar.gz"
        tar -xzf "$TEMP_DIR/yazi.tar.gz" -C "$TEMP_DIR"
        install "$TEMP_DIR/yazi"*/yazi /usr/local/bin/
        rm -rf "$TEMP_DIR"
      become: yes
  when: yazi_check.rc != 0
  tags: ['manual', 'yazi']

###############################################################################
# Tmux (special: compile from source)
###############################################################################

- name: Check if Tmux is installed
  command: which tmux
  environment:
    PATH: "{{ extended_path }}"
  register: tmux_check
  ignore_errors: yes
  changed_when: false
  tags: ['manual', 'tmux']

- name: Install Tmux from source
  block:
    - name: Install Tmux build dependencies
      apt:
        name:
          - libevent-dev
          - ncurses-dev
          - build-essential
          - bison
          - pkg-config
          - autoconf
          - automake
        state: present
      become: yes

    - name: Clone Tmux repository
      git:
        repo: https://github.com/tmux/tmux.git
        dest: /tmp/tmux-build
        version: master
        force: yes

    - name: Build and install Tmux
      shell: |
        cd /tmp/tmux-build
        sh autogen.sh
        ./configure
        make
        make install
        rm -rf /tmp/tmux-build
      become: yes
  when: tmux_check.rc != 0
  tags: ['manual', 'tmux']

###############################################################################
# Kubecolor (special: deb package with version detection)
###############################################################################

- name: Check if Kubecolor is installed
  command: which kubecolor
  environment:
    PATH: "{{ extended_path }}"
  register: kubecolor_check
  ignore_errors: yes
  changed_when: false
  when: "'kubecolor' in all_apt_packages | map(attribute='name') | list"
  tags: ['manual', 'kubecolor']

- name: Install Kubecolor
  block:
    - name: Ensure apt-transport-https and wget are installed
      apt:
        name: [apt-transport-https, wget]
        state: present
      become: yes

    - name: Get Kubecolor version
      shell: wget -q -O- https://kubecolor.github.io/packages/deb/version
      register: kubecolor_version
      changed_when: false

    - name: Download Kubecolor deb package
      get_url:
        url: "https://kubecolor.github.io/packages/deb/pool/main/k/kubecolor/kubecolor_{{ kubecolor_version.stdout }}_{{ dpkg_arch.stdout }}.deb"
        dest: /tmp/kubecolor.deb

    - name: Install Kubecolor
      apt:
        deb: /tmp/kubecolor.deb
      become: yes

    - name: Clean up Kubecolor deb package
      file:
        path: /tmp/kubecolor.deb
        state: absent
  when:
    - "'kubecolor' in all_apt_packages | map(attribute='name') | list"
    - kubecolor_check.rc | default(1) != 0
  tags: ['manual', 'kubecolor']

###############################################################################
# Obsidian (special: deb from GitHub)
###############################################################################

- name: Check if Obsidian is installed
  command: which obsidian
  environment:
    PATH: "{{ extended_path }}"
  register: obsidian_check
  ignore_errors: yes
  changed_when: false
  tags: ['manual', 'obsidian']

- name: Install Obsidian
  shell: |
    curl -sI https://github.com/obsidianmd/obsidian-releases/releases/latest | grep -oP 'v\K[0-9.]+' | xargs -I{} curl -Lo /tmp/obsidian.deb "https://github.com/obsidianmd/obsidian-releases/releases/download/v{}/obsidian_{}_amd64.deb"
    dpkg -i /tmp/obsidian.deb || apt-get -f install -y
    rm -f /tmp/obsidian.deb
  become: yes
  when: obsidian_check.rc != 0
  tags: ['manual', 'obsidian']

###############################################################################
# kubectl (special: binary download)
###############################################################################

- name: Check if kubectl is installed
  command: which kubectl
  environment:
    PATH: "{{ extended_path }}"
  register: kubectl_check
  ignore_errors: yes
  changed_when: false
  tags: ['manual', 'kubectl']

- name: Install kubectl
  shell: |
    curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
    rm -f kubectl
  become: yes
  when: kubectl_check.rc != 0
  tags: ['manual', 'kubectl']

###############################################################################
# Google Cloud CLI (special: tarball to home directory)
###############################################################################

- name: Check if gcloud is installed
  command: which gcloud
  environment:
    PATH: "{{ extended_path }}"
  register: gcloud_check
  ignore_errors: yes
  changed_when: false
  tags: ['manual', 'gcloud']

- name: Install Google Cloud CLI
  block:
    - name: Download gcloud CLI tarball
      get_url:
        url: https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-cli-linux-x86_64.tar.gz
        dest: /tmp/google-cloud-cli.tar.gz

    - name: Remove existing gcloud installation
      file:
        path: "{{ ansible_env.HOME }}/google-cloud-sdk"
        state: absent

    - name: Extract gcloud CLI to home directory
      unarchive:
        src: /tmp/google-cloud-cli.tar.gz
        dest: "{{ ansible_env.HOME }}"
        remote_src: yes

    - name: Run gcloud install script
      shell: "{{ ansible_env.HOME }}/google-cloud-sdk/install.sh --quiet --path-update=false --command-completion=false"

    - name: Clean up tarball
      file:
        path: /tmp/google-cloud-cli.tar.gz
        state: absent
  when: gcloud_check.rc != 0
  tags: ['manual', 'gcloud']
